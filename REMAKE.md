## 多进程编程
* 意义：充分利用计算机多核资源，提高程序的运行效率
* 并行
>同时处理多个任务，内核在任务间不断的切换达到好像多个任务被同时执行的效果
* 并发
>多个任务利用计算机多核资源在同时执行，此时多个任务间为并行关系

### 进程理论基础
* 定义：程序在计算机中的一次运行
> * **程序是静态的，进程是动态的**

* 进程是如何产生的
>1. 用户空间通过调用程序接口或者命令发起请求
>2. 操作系统接收用户请求，开始创建进程
>3. 操作系统调配计算机资源，确定进程状态等
>4. 操作系统将创建的进程提供给用户使用

* cpu时间片：如果一个进程战友cpu内核则称这个进程在cpu时间片上
* PCB(进程控制块)：在内存中开辟的一块空间，用于存放进程的基本信息，也用于系统查找识别进程
* 进程ID(PID)：系统为每个进程分配的一个大于０的整数，作为进程ＩＤ．每个进程ID不重复(查看进程ID: **ps -aux**)
* 父子进程:系统中每一个进程(除了系统进程初始化进程)都有唯一的父进程，可以有０个或多个子进程．父子进程关系便于进程管理（查看进程树：**pstree**）
* 进程状态

>三态
>>就绪态：进程具备执行条件，等待分配cpu资源
>>运行态：进程占有cpu时间片正在运行
>>等待态：进程暂时停止运行，让出cpu

>五态(在三态基础上增加新建和终止)
>>新建：创建一个进程，获取资源的过程
>>终止：进程结束，释放资源的过程

* 进程的运行特征
[1] 进程可以使用计算机多核资源
[2] 进程是计算机分配资源的最小单位
[3] 进程之间的运行互不影响，各自独立
[4] 每个进程拥有独立的空间，各自使用自己空间资源

### 基于fork的多进程编程
* 创建新的进程(**pid = os.fork()**)
* 返回值：整数，如果创建进程失败返回一个负数，如果成功则在原有进程中返回新进程PID，在新进程返回０
* 特点：
>1. 子进程会复制父进程全部内存空间，从fork下一句开始执行
>2. 父子进程各自独立运行，运行顺序不一定
>3. 利用父子进程fork返回值的区别，配合if结构让父子进程执行不同的内容几乎是固定搭配
>4. 父子进程有各自特有特征比如PID，PCB命令集等
>5. 父进程fork之前开辟的空间子进程同样拥有，父子进程对各自空间的操作不会相互影响
* 相关函数
>* **os.getpid()** 获取一个进程的PID值
>* **os.getppid()** 获取父进程的PID值
>* **os._exit()** 结束一个进程

#### 孤儿和僵尸进程

* 孤儿进程：父进程先于子进程退出，此时子进程成为孤儿进程
>特点：孤儿进程会被系统进程收养，此时系统就会成为孤儿进程的父进程，孤儿进程退出该进程会自动处理
* 僵尸进程：子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会成为僵尸进程
>特点：僵尸进程虽然结束，但是会存留部分PCB在内存中，大量的僵尸进程会浪费系统的内存资源
* 避免处理僵尸进程

>* 创建二级子进程处理僵尸
>>1. 父进程创建子进程，等待回收子进程
>>2. 子进程创建二级子进程然后退出
>>3. 二级子进程称为孤儿，和原来父进程一同执行事件

>***参考代码fork01.py***

>* 通过信号处理子进程退出
>>1. 原理：子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动处理子进程退出
>>2. 方法：
	```
	import signal
	signal.signal(signal.SIGCHLD, signal.SIG_IGN)
	```
>>3. 特点：非阻塞，不会影响父进程运行．可以处理所有子进程退出

>***参考代码fork02.py***
### multiprocessing 模块创建进程
* 流程特点
>* 将需要的子进程执行的事件封装为函数
>* 通过模块的Process类创建进程对象，关联函数
>* 可以通过进程对象设置进程信息及属性
>* 通过进程对象调用start()启动进程
>* 通过进程对象调用join()回收进程

***参考代码process01.py***

* 基本接口使用
```
p = Process() # 创建进程对象
参数：target 绑定要执行的目标函数
	args 元组，用于给target函数位置传参
	kwargs 字典，给target函数键值传参
```
***参考代码process02.py***
